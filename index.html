<html>
<!--
	The canvas tower defense game! :)
    Copyright (C) 2013  RenÃ© van der Ark

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
-->
<head>
	<script type="text/javascript" src="rgbcolor.js"></script> 
	<script type="text/javascript" src="canvg.js"></script> 
	<script type="text/javascript" src="astarWorker.js"></script> 
	<meta name="viewport" content="width=device-width, initial-scale=0.5, user-scalable=no"/>

	<script type="text/javascript">
		var settings = {
			scaleFactor: 1.0
		};

		var sounds = {};


		var Sprite = function(svg, w, h, scaleFactor) {
			var canvas1 = document.createElement('canvas');
			var canvasArray = [];
			this.init = function(initW, initH) {
				var ctx1 = canvas1.getContext('2d');
				w = Math.floor((initW || w) / settings.scaleFactor);
				h = Math.floor((initH || h) / settings.scaleFactor);
				canvas1.width = w;
				canvas1.height = h;

				ctx1.drawSvg(svg, 0, 0, w, h); 
				for(var deg = 0; deg < 361; deg++) {
					canvasArray[deg] = document.createElement('canvas');					
					canvasArray[deg].width = w;
					canvasArray[deg].height = h;
					var ctx = canvasArray[deg].getContext('2d');
					_draw(ctx, deg);
				}
			}

			function _rotate(ctx, ang) {
				ctx.rotate(ang * (Math.PI / 180));
			}

			function _drawImage(ctx) {
				ctx.drawImage(canvas1, -(w/2), -(h/2));
			}

			var _draw = function(ctx, ang) {
				ctx.save();
				ctx.translate((w/2), (h/2));
				_rotate(ctx, ang);
				_drawImage(ctx);
				ctx.restore();
			};

			this.draw = function(ctx, x, y, angF) {
				var ang = parseInt(angF);
				if(ang < 0) { ang = 360 + ang; }
				ctx.drawImage(canvasArray[ang], 
					Math.floor(x / settings.scaleFactor), 
					Math.floor(y / settings.scaleFactor));
				return {
					x : Math.ceil(x / settings.scaleFactor)-1, 
					y : Math.ceil(y / settings.scaleFactor)-1,
					w : Math.ceil(w)+2,
					h : Math.ceil(h)+2,
				};
			}


			this.getW = function() { return w * settings.scaleFactor; }
			this.getH = function() { return h * settings.scaleFactor; }
			this.init();
		}

		var sprites = {
			creep: new Sprite("creep.svg", 8, 8),
			pelletTower:  new Sprite("pellet.svg", 20, 20),
			bullet: new Sprite("bullet.svg", 5,5)
		};

		var Grid = function(ctx, fgCtx, options) {
			var opts = options || {};
			var width = opts.width || 32;
			var height = opts.height || 32;
			var ghost = {x : -1, y : -1, w : 2, h : 2};
			var occupiedSquares = [];
			var clearGhostRect = null;
			var astarWorker = new Worker('astarWorker.js');

			this.setGhost = function(dims) {
				ghost.x = dims.x;
				ghost.y = dims.y;
				ghost.w = dims.w || ghost.w;
				ghost.h = dims.h || ghost.h;
			};

			this.getGhost = function() { return ghost; };

			this.clearGhost = function() {
				if(clearGhostRect) {
					fgCtx.clearRect(clearGhostRect.x, clearGhostRect.y, clearGhostRect.w, clearGhostRect.h);
				}
			};

			this.drawGhost = function() { 
				if(ghost.x > -1 && ghost.y > -1) {
					fgCtx.fillStyle = "rgba(128,128,128,0.3)";	
					fgCtx.fillRect(ghost.x * 10 / settings.scaleFactor, 
						ghost.y * 10 / settings.scaleFactor, 
						ghost.w * 10 / settings.scaleFactor,
						ghost.h * 10 / settings.scaleFactor);

					clearGhostRect = { 
						x: Math.ceil(ghost.x * 10 / settings.scaleFactor) - 1, 
						y: Math.ceil(ghost.y * 10 / settings.scaleFactor) - 1, 
						w: Math.ceil(ghost.w * 10 / settings.scaleFactor) + 2,
						h: Math.ceil(ghost.h * 10 / settings.scaleFactor) + 2
					};
				}
			};

			this.drawOccupied = function() {
				ctx.strokeStyle = "#f00";
				ctx.beginPath();

				for(var x = 0; x < width; x++) {
					for(var y = 0; y < height; y++) {
						if(occupiedSquares[x + "-" + y] == true) {
							ctx.rect(
								x * 10 / settings.scaleFactor, 
								y * 10 / settings.scaleFactor, 
								10 / settings.scaleFactor,
								10 / settings.scaleFactor);
						}
					}
				}
				ctx.stroke();
			};

			this.draw = function() {
				ctx.beginPath();
				ctx.strokeStyle = "black";
				ctx.lineWidth = 0.2;
				for(var x = 10; x <= 320; x += 10) {
					ctx.moveTo(0, x / settings.scaleFactor);
					ctx.lineTo(320 / settings.scaleFactor, x / settings.scaleFactor);
					ctx.moveTo(x / settings.scaleFactor, 0);
					ctx.lineTo(x / settings.scaleFactor, 320 / settings.scaleFactor);
				}
				ctx.stroke();	
				ctx.lineWidth = 1;
			};

			this.occupy = function(spaces) {
				for(var x = spaces.x; x < spaces.x + spaces.w; x++) {
					for(var y = spaces.y; y < spaces.y + spaces.h; y++) {
						occupiedSquares[x + "-" + y] = true;
					}
				}
			};

			this.deOccupy = function(spaces) {
				for(var x = spaces.x; x < spaces.x + spaces.w; x++) {
					for(var y = spaces.y; y < spaces.y + spaces.h; y++) {
						occupiedSquares[x + "-" + y] = false;
						ctx.clearRect(
							Math.floor(x * 10 / settings.scaleFactor) - 1, 
							Math.floor(y * 10 / settings.scaleFactor) - 1, 
							Math.ceil(10 / settings.scaleFactor) + 2,
							Math.ceil(10 / settings.scaleFactor) + 2);	
					}
				}
			};

			this.available = function(spaces) {
				for(var x = spaces.x; x < spaces.x + spaces.w; x++) {
					for(var y = spaces.y; y < spaces.y + spaces.h; y++) {
						if(occupiedSquares[x + "-" + y] == true) { return false; }
					}
				}
				return true;
			};

			var pathSubjects = [];
			astarWorker.addEventListener('message', function(msg) {
				//console.log("A*: " + msg.data.timed + "ms");
				pathSubjects[msg.data.subjectKey].handlePath(msg.data.path, msg.data.requestTimeIndex);
			}, false);

			this.testPath = function(from, to, subject) {
				return aStar({data: {
					from: from, 
					to: to, 
					occupiedSquares: occupiedSquares,
					width: width,
					height: height
				}}).length > 0;
			};

			this.getPath = function(from, to, subject) {
				var pathTimeIndex = new Date().getTime();
				pathSubjects[subject.getHashKey()] = subject;
				subject.setPathTimeIndex(pathTimeIndex);

				astarWorker.postMessage({
					from: from, 
					to: to, 
					occupiedSquares: occupiedSquares,
					width: width,
					height: height,
					subjectKey: subject.getHashKey(),
					requestTimeIndex: pathTimeIndex
				});
			};
		};

		function makeid() {
		    var text = "";
		    var possible = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";

		    for(var i = 0; i < 5; i++) {
        		text += possible.charAt(Math.floor(Math.random() * possible.length));
			}
		    return text + "-" + new Date().getTime();
		}

		var GameObject = function(sprite, ctx, options) {
			var opts = options || {};
			var speed = opts.speed || 1;
			var ang = opts.angle || 0;
			var x = opts.x || 0;
			var y = opts.y || 0;
			var z = opts.zIndex || 0;
			var path = [];
			var clearRect = null;
			var bgBuf = document.createElement("canvas");
			var updated = true;
			var hashKey = makeid();
			var _index = -1;
			var newPath = [];
			var pathTimeIndex = 0;
			var pathPending = false;
			
			
			this.setIndex = function(idx) { _index = idx; }
			this.getIndex = function() { return _index; }
			this.isUpdated = function() { return updated; }
			this.setUpdated = function(up) { updated = up; }
			this.getHashKey = function() { return hashKey; }

			this.setPathTimeIndex = function(ts) { pathTimeIndex = ts; }

			this.clear = function() {
				if(clearRect) {
					ctx.clearRect(clearRect.x, clearRect.y, clearRect.w, clearRect.h);
				}
			}

			this.draw = function() {
				clearRect = sprite.draw(ctx, x - (sprite.getW()/2), y - (sprite.getH()/2), ang);
				updated = false;
			}

			this.getX = function() { return x; };
			this.getY = function() { return y; };
			this.getZ = function() { return z; };
			
			this.setX = function(setX) { x = setX; };
			this.setY = function(setY) { y = setY; };

			this.isPathPending = function() { return pathPending; };

			this.getPathTo = function(grid, target)  {
				pathPending = true;
				grid.getPath({x : Math.floor(x / 10), y : Math.floor(y / 10) }, target, this);
			};

			this.handlePath = function(p, requestTimeIndex) {
				/** if this handler was called by an outdated worker, ignore it **/
				if(requestTimeIndex < pathTimeIndex) { return; }
				pathPending = false;
				newPath = p;
			};

			this.getNewPath = function() { return newPath; };

			this.setPath = function(setPath) {
				path = (setPath || []);
			};

			/** Action queue targets; returning true means target is achieved and action can be removed from the queue **/
			this.followPath = function() {
				if(path.length == 0) { return true; }
				var t = path[0];
				if(t  == undefined) { return; }
				if(this.moveTo(t.x * 10 + 5, t.y * 10 + 5)) {
					path.shift();
				}
				return false;
			};

			this.moveTo = function(targetX, targetY) {
				updated = true;
				var deltaX = targetX - x;
				var deltaY = targetY - y;
				var mag = Math.sqrt((deltaX * deltaX) + (deltaY * deltaY));
				ang = Math.atan2(deltaY, deltaX) * (180 / Math.PI) + 90;
				var nextX = x + ((deltaX / mag) * speed);
				var nextY = y + ((deltaY / mag) * speed);
				if(nextX - targetX > -1 && nextX - targetX < 1 && nextY - targetY > -1 && nextY - targetY < 1) {
					x = targetX; y = targetY;
					return true;
				}
				x = nextX; y = nextY;
				return false;
			};

			this.moveToOther = function(otherObject) {
				return this.moveTo(otherObject.getX(), otherObject.getY());
			};

			this.pointTo = function(otherObject) {
				updated = true;
				var deltaX = otherObject.getX() - x;
				var deltaY = otherObject.getY() - y;
				ang = Math.atan2(deltaY, deltaX) * (180 / Math.PI) + 90;
				return false;
			};			
		}

		var PelletTower = function(opts) {
			var level = 1;
			var range = 30;
			var maxBullets = 1;

			var ctx = opts.context;
			var bulletCtx = opts.bulletContext;
			var grid = opts.grid;
			var gridX = opts.x;
			var gridY = opts.y;
			var gameObject = new GameObject(sprites.pelletTower, ctx, {x: (gridX + 1) * 10, y: (gridY + 1) * 10, zIndex: 0});
			var bullet = new GameObject(sprites.bullet, bulletCtx, {x: gameObject.getX(), y: gameObject.getY(), zIndex: 0, speed: 1});

			this.getGameObject = function() { return gameObject; }
			this.getBullet = function() { return bullet; }

			var _pollPaths = function(creeps, onFailure, onSuccess) {

				for(var i in creeps) {
					if(creeps[i].isPathPending()) {
						setTimeout(function() { _pollPaths(creeps, onFailure, onSuccess) }, 1);
						return;
					}
					if(creeps[i].getNewPath().length == 0) {
						_deOccupyGrid();
						onFailure("Creep path is blocked");
						return;
					}
				}
				onSuccess();
			};

			var _deOccupyGrid = function() {
				grid.deOccupy({x: gridX, y: gridY, w: 2, h: 2});
			};

			this.place = function(opts) {				
				if(!grid.available({x: gridX, y: gridY, w: 2, h: 2})) { 
					opts.onFailure("Grid space is occupied"); 
					return;
				}

				grid.occupy({x: gridX, y: gridY, w: 2, h: 2});
				if(!grid.testPath({x: 0, y: 15}, {x: 31, y: 15}) ||
					!grid.testPath({x: 15, y: 0}, {x: 15, y: 31})) {
					_deOccupyGrid();
					opts.onFailure("Paths are blocked");
					return;
				}

				for(var x in opts.creeps) {
					opts.creeps[x].getPathTo(grid, {x: 31, y: 15});
				}

				_pollPaths(opts.creeps, opts.onFailure, opts.onSuccess);
			};

			

			var _shootAt = function(otherGameObject) {
				gameObject.pointTo(otherGameObject); 
				if(bullet.moveToOther(otherGameObject)) {
					bullet.setX(gameObject.getX());
					bullet.setY(gameObject.getY());
					sounds.bullet.play();
				}
				return false;	
			};

			this.shootAtFirstWithinRange = function(others) {
				for(var i in others) {
					var deltaX = others[i].getX() - gameObject.getX();
					var deltaY = others[i].getY() - gameObject.getY();
					var distance = Math.sqrt((deltaX * deltaX) + (deltaY * deltaY));
					if(distance <= range) { return _shootAt(others[i]); }
				}
				bullet.setX(gameObject.getX());
				bullet.setY(gameObject.getY());
				bullet.setUpdated(true);
				return false;
			};
		};

		var Sample = function(audio, opts) {
			var _nChannels = opts.channels || 1;
			var _channels = [];
			var _firstTimers = [];
			for(var i = 0; i < _nChannels; i++) {
				_channels[i] = audio.cloneNode();
				_firstTimers[i] = _channels[i];
			}

			this.play = function() {
				if(_firstTimers.length > 0) { 
					_firstTimers.pop().play(); 
					return; 
				}
				for(var i = 0; i < _nChannels; i++) {
					if(_channels[i].ended) {
						_channels[i].play();
						return;
					}
				}
			};
		};


		window.requestAnimFrame = (function(){

		  return  window.requestAnimationFrame       ||
			  window.webkitRequestAnimationFrame ||
			  window.mozRequestAnimationFrame    ||
			  function( callback ){
			    window.setTimeout(callback, 1000 / 60);
			  };
		})();


		window.onload = function() {
			var c = document.getElementById('canvas');
			doResize();
			var ctx = c.getContext('2d');
			var bgCtx = document.getElementById('bg').getContext('2d');
			var mgCtx = document.getElementById('mg').getContext('2d');

			var grid = new Grid(bgCtx, ctx);
			var path = [];

			var creeps = [];
			var towers = [];
			var gameObjects = [];


			sounds.bullet = new Sample(new Audio("plop.wav"), {channels: 5});



			function doResize() {
				var c = document.getElementById('canvas');
				var ww = (window.innerWidth || document.body.clientWidth) - 50;
				var wh = (window.innerHeight || document.body.clientHeight) - 50;
				c.width =  (ww > wh ? wh : ww);
				c.height = c.width;
				document.getElementById('bg').width = c.width;
				document.getElementById('bg').height = c.height;
				document.getElementById('mg').width = c.width;
				document.getElementById('mg').height = c.height;
				settings.scaleFactor = 310 / c.width;
				sprites.creep.init(8,8);
				sprites.pelletTower.init(20,20);
				sprites.bullet.init(4,4);
				for(i in gameObjects) { if(gameObjects[i]) { gameObjects[i].setUpdated(true); } }
			}
			window.onresize = doResize;


			for(var i = 0; i < 20; ++i) {
				var creep = new GameObject(sprites.creep, mgCtx, {x: -(5*i) * settings.scaleFactor, y: 75 / settings.scaleFactor, zIndex: 1, speed: 0.3});
				creeps.push(creep);
				gameObjects.push(creep);
				creep.getPathTo(grid, {x: 31, y: 15});				
			}

			var target = {x : 0, y : 0};
			var blockNewPlacement = false;
			document.getElementById("canvas").onclick = function(e) {
				if(blockNewPlacement) {
					shinyMessage("still validating last placement");
				} else {
					var pelletTower = new PelletTower({bulletContext: bgCtx, context: mgCtx, grid: grid, x: grid.getGhost().x, y: grid.getGhost().y});
					blockNewPlacement = true;

					pelletTower.place({
						creeps: creeps,
						onSuccess: function() { 
							towers.push(pelletTower);
							gameObjects.push(pelletTower.getGameObject());
							gameObjects.push(pelletTower.getBullet());
							for(var i in creeps) {
								creeps[i].setPath(creeps[i].getNewPath());
							}
							blockNewPlacement = false;
						},
						onFailure: function(reason) {
							shinyMessage(reason);
							blockNewPlacement = false;
						}
					});
				}
			};

			document.getElementById("canvas").onmouseout = function(e) {
				grid.setGhost({ x : -1, y : -1 });
			};

			document.getElementById("canvas").onmousemove = function(e) {
				grid.setGhost({
					x : Math.floor(((e.pageX - this.offsetLeft) * settings.scaleFactor) / 10),
					y : Math.floor(((e.pageY - this.offsetTop) * settings.scaleFactor) / 10)
				});
			};

			function processActionQueue() {
				for(var i in towers) {
					towers[i].shootAtFirstWithinRange(creeps); 
				}
				for(var i in creeps) {
					if(creeps[i].followPath()) {
						creeps.splice(i, 1);
						shinyMessage(creeps.length +  " creeps left");
					}
				}
			}


			var redrawList = [];
			function pushUpdatesToCanvas() {
				for(var i in gameObjects) {
					if(gameObjects[i] && gameObjects[i].isUpdated() /**&& $.inArray(gameObjects[i], redrawList) == -1**/) {
						redrawList.push(gameObjects[i]);
					}
				}
				redrawList.sort(function(a,b) { return b.getZ() - a.getZ(); });
			}

			function processTick() {
				grid.clearGhost();
				grid.drawGhost();
//				grid.drawOccupied();

				processActionQueue();
				pushUpdatesToCanvas();

				var start = new Date().getTime();
				var i = 0;
				var drawList = [];
				while(redrawList.length > 0 && ++i < 500) {
					var gameObject = redrawList.pop();
					gameObject.clear();
					drawList.push(gameObject);
				}

				for(var x in drawList) { drawList[x].draw(); }
				requestAnimFrame(processTick);
			}

			function pollForPaths() {
				for(var i in creeps) {
					if(creeps[i].isPathPending()) {
						setTimeout(pollForPaths, 1);
						return;
					} else { 
						creeps[i].setPath(creeps[i].getNewPath());
					}
				}
				processTick();
			}
			pollForPaths();
		};

		function shinyMessage(txt) {
			document.getElementById('msg').innerHTML = txt;
		}
	</script>
</head>
<body>
<a href="http://github.com/renevanderark/canvas-td">back to github</a>
<span id="msg"></span>
<canvas id="bg" style="border: 1px solid; margin: 0; position: absolute; z-index: 0; left: 0; top: 30">
</canvas>
<canvas id="mg" style="border: 1px solid; margin: 0; position: absolute; z-index: 1; left: 0; top: 30">
</canvas>
<canvas id="canvas" style="border: 1px solid; margin: 0; position: absolute; z-index: 2; left: 0; top: 30">
</canvas>


</html>
